#include "stdafx.h"

using namespace IceRenderManager;

	class ZCBFactory : public ZCBBreaker
	{
		public:
		// Constructor/Destructor
											ZCBFactory();
		virtual								~ZCBFactory();

		virtual			bool				NewScene				(const ZCBSceneInfo& scene);
		virtual			bool				NewCamera				(const ZCBCameraInfo& camera);
		virtual			bool				NewLight				(const ZCBLightInfo& light);
		virtual			bool				NewMaterial				(const ZCBMaterialInfo& material);
		virtual			bool				NewTexture				(const ZCBTextureInfo& texture);
		virtual			bool				NewMesh					(const ZCBMeshInfo& mesh);
		virtual			bool				NewShape				(const ZCBShapeInfo& shape);
		virtual			bool				NewHelper				(const ZCBHelperInfo& helper);
		virtual			bool				NewController			(const ZCBControllerInfo& controller);
		virtual			bool				NewMotion				(const ZCBMotionInfo& motion);

		virtual			bool				ZCBImportError			(const char* errortext, udword errorcode);
		virtual			void				ZCBLog					(LPSTR fmt, ...);

		private:
	};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	This factory is used to make the render manager independent from ZCB files. This is an interface between the ZCB breaker and the app.
 *	Theoretically the factory is called by the ZCB breaker, fills some app-dependent creation structure, then call the generic object creation
 *	methods from the app. The other way would have been to support ZCB structures natively in the app, which is possible but not generic enough
 *	and probably not user-friendly (some may want to use the render manager with their own data format). This design is cleaner since it ensures
 *	the app HASA ZCB breaker, whereas the older design ensures the app ISA ZCB breaker.
 *
 *	\class		ZCBFactory
 *	\author		Pierre Terdiman
 *	\version	1.0
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Constructor.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ZCBFactory::ZCBFactory()
{
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Destructor.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ZCBFactory::~ZCBFactory()
{
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Overriden error handler.
 *	\param		errortext	[in] text message
 *	\param		errorcode	[in] error code
 *	\return		true if success.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool ZCBFactory::ZCBImportError(const char* errortext, udword errorcode)
{
	printf("Error: %s\n", errortext);
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Overriden log handler.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ZCBFactory::ZCBLog(LPSTR fmt, ...)
{
	char buff[1024];

	va_list va;

	va_start(va, fmt);
	vsprintf(buff, fmt, va);
	va_end(va); 

	printf("LOG: ");
	printf((const char*)buff);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	A method to create a new scene.
 *	\param		scene		[in] the new scene info structure
 *	\return		true if success.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool ZCBFactory::NewScene(const ZCBSceneInfo& scene)
{
	printf("Importing new scene...\n");
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	A method to create a new camera.
 *	\param		camera		[in] the new camera info structure
 *	\return		true if success.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool ZCBFactory::NewCamera(const ZCBCameraInfo& camera)
{
	printf("Importing new camera...\n");
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	A method to create a new controller.
 *	\param		controller		[in] the new controller info structure
 *	\return		true if success.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool ZCBFactory::NewController(const ZCBControllerInfo& controller)
{
	printf("Importing new controller...\n");
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	A method to create a new helper.
 *	\param		helper		[in] the new helper info structure
 *	\return		true if success.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool ZCBFactory::NewHelper(const ZCBHelperInfo& helper)
{
	printf("Importing new helper...\n");
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	A method to create a new light.
 *	\param		light		[in] the new light info structure
 *	\return		true if success.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool ZCBFactory::NewLight(const ZCBLightInfo& light)
{
	printf("Importing new light...\n");
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	A method to create a new material.
 *	\param		material		[in] the new material info structure
 *	\return		true if success.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool ZCBFactory::NewMaterial(const ZCBMaterialInfo& material)
{
	printf("Importing new material...\n");
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	A method to create a new mesh.
 *	\param		mesh		[in] the new mesh info structure
 *	\return		true if success.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool ZCBFactory::NewMesh(const ZCBMeshInfo& mesh)
{
	printf("Importing new mesh...\n");
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	A method to create a new shape.
 *	\param		shape		[in] the new shape info structure
 *	\return		true if success.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool ZCBFactory::NewShape(const ZCBShapeInfo& shape)
{
	printf("Importing new shape...\n");
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	A method to create a new motion.
 *	\param		motion		[in] the new motion info structure
 *	\return		true if success.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool ZCBFactory::NewMotion(const ZCBMotionInfo& motion)
{
	printf("Importing new motion...\n");
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	A method to retrieve the texture information from a ZCB info structure.
 *	\param		texture		[in] the imported texture info structure.
 *	\return		Self-Reference.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool ZCBFactory::NewTexture(const ZCBTextureInfo& texture)
{
	printf("Importing new texture...\n");
	return true;
}





int main(int argc, char* argv[])
{
	ZCBFactory Factory;

	Factory.Import("c:\\zcb\\Scenes\\archipelago4.zcb");
//	Factory.Import("c:\\zcb\\cancan441.zcb");
//	Factory.Import("c:\\zcb\\Test_OBB.zcb");

	return 0;
}
