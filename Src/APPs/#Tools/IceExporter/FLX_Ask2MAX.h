///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
 *	FLEXPORTER - a flexible exporter
 *	Copyright (C) 2000-2004 Pierre Terdiman
 *	Homepage: http://www.codercorner.com/Flexporter.htm
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	This file contains various functions asking basic questions to MAX.
 *	I didn't bother putting them in a class, since it seemed quite totally pointless!
 *
 *	\file		FLX_Ask2MAX.h
 *	\author		Pierre Terdiman
 *	\date		April, 4, 2000
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Include Guard
#ifndef FLX_ASK2MAX_H
#define FLX_ASK2MAX_H

	// Texmaps
	#define TEXMAP_UNKNOWN		-2
	#define TEXMAP_UNDEFINED	-1
	#define TEXMAP_BITMAP		1

	enum MAXTextureID
	{
		TEXTURE_ID_AMBIENT			= ID_AM,
		TEXTURE_ID_DIFFUSE			= ID_DI,
		TEXTURE_ID_SPECULAR			= ID_SP,
		TEXTURE_ID_SHININESS		= ID_SH,
		TEXTURE_ID_SHINING_STRENGTH	= ID_SS,
		TEXTURE_ID_SELF_ILLUM		= ID_SI,
		TEXTURE_ID_OPACITY			= ID_OP,
		TEXTURE_ID_FILTER_COLOR		= ID_FI,
		TEXTURE_ID_BUMP				= ID_BU,
		TEXTURE_ID_REFLECTION		= ID_RL,
		TEXTURE_ID_REFRACTION		= ID_RR,
		TEXTURE_ID_DISPLACEMENT		= ID_DP,

		TEXTURE_ID_FORCE_DWORD		= 0x7fffffff
	};

	// Global functions
	void			DoSomeTest();

	inline_ void	VectorToColor(const Point& vector, BMM_Color_64& color)
					{
						// We assume the vector is a unit vector whose components range from -1 to +1
						Point tmp = vector;

						// => [0;2]
						tmp.x += 1.0f;
						tmp.y += 1.0f;
						tmp.z += 1.0f;

						// => [0;1]
						tmp *= 0.5f;

						// Handle epsilons
						tmp.Clamp(0.0f, 1.0f);

						// Convert to color
						color.r = tmp.x * 65535.0f;
						color.g = tmp.y * 65535.0f;
						color.b = tmp.z * 65535.0f;
					}

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 *	Checks if a given node is a root one.
	 *	There's an INode method called IsRootNode(), but this is not what we expect..
	 *	\param		node	[in] a MAX node
	 *	\return		true for root node
	 */
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	bool			IsRootNode(INode* node);

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 *	Checks if a given texmap is exportable.
	 *	We only export bitmap-texmaps for the moment.
	 *	\param		tmap	[in] a MAX texmap
	 *	\return		error code
	 */
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	ubyte			IsKnownTexmap(Texmap* tmap);

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 *	Checks a MAX material is a valid one.
	 *	\param		material			[in] a MAX material
	 *	\param		invalid_materials	[out] a possible container to store invalid material pointers (or null)
	 *	\return		true if the material is valid
	 */
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	bool			_IsValidMaterial(Mtl* material, Container* invalid_materials=null);

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 *	Checks a node is mirrored or not.
	 *	\param		node		[in] a MAX node
	 *	\param		time_value	[in] a time value
	 *	\return		true if mirrored
	 */
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	bool			IsMirrored(INode* node, long time_value);

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 *	Gets the total number of nodes in a MAX scene, including root node.
	 *	\param		current_node	[in] MAX root node
	 *	\return		total number of nodes
	 */
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	udword			GetNbNodes(INode* current_node);

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 *	Finds a node given its name.
	 *	\param		current_node	[in] MAX root node
	 *	\param		name			[in] name of the node we're looking for
	 *	\return		node of given name, or null if not found
	 */
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	INode*			_FindNode(INode* current_node, const char* name);

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 *	Gets a tri-mesh from a MAX object.
	 *	\param		nodeobject		[in] a MAX object
	 *	\param		time			[in] current time value
	 *	\return		the trimesh
	 */
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	::Mesh*			GetMeshFromObject(Object* nodeobject, TimeValue time);

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 *	Catches some time-related infos
	 *	\param		ip			[in] MAX interface
	 *	\param		result		[out] the result structure
	 */
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void			GetTimeInfo(Interface* ip, MAXTimeInfo& result);

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 *	Checks whether a node has counter-clockwise faces or not.
	 *	Looks like that's the same as checking for negative scales...
	 *	\param		node			[in] a MAX node pointer
	 *	\param		current_time	[in] the current frame
	 *	\return		false for standard meshes, true for mirrored ones.
	 */
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	bool			GetParity(INode* node, TimeValue current_time);

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 *	Gets the crop values for a given texmap.
	 *	\param		tmap			[in] current texmap
	 *	\param		crop			[out] a result structure filled with crop values
	 *	\param		uvtrans			[out] the texture matrix
	 *	\param		current_time	[in] current MAX time
	 *	\return		true if success
	 */
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	bool			GetCropValues(Texmap* tmap, TextureCrop& crop, Matrix3& uvtrans, TimeValue current_time);

	bool			GetTextureTiling(Texmap* tmap, udword& tiling_u, udword& tiling_v);

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 *	Gets the offset matrix from a node.
	 *	\param		node	[in] MAX node
	 *	\return		MAX offset matrix
	 */
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	Matrix3			GetOffsetMatrix(INode* node);

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 *	Gets units data.
	 *	\param		units	[out] current units
	 *	\return		true if success
	 */
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	bool			GetUnits(MAXUnits& units);

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 *	Dumps MAX selection in a dedicated array.
	 *	\param		ip		[in] MAX interface
	 *	\param		nodes	[out] array of selected nodes
	 *	\return		true if success
	 */
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	bool			GetSelectedNodes(Interface* ip, MAXNodes& nodes);

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 *	Gets the bitmap array from a MAX node.
	 *	\param		node			[in] MAX node
	 *	\param		texture_id		[in] id of desired texture (diffuse, etc)
	 *	\param		current_time	[in] current time for animated textures
	 *	\return		bitmap storage pointer, or null
	 */
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	BitmapStorage*	GetBitmapStorage(INode* node, MAXTextureID texture_id, TimeValue current_time);

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 *	Fills a MAX bitmap array with a given color.
	 *	\param		bitmap_storage	[in] MAX bitmap storage pointer
	 *	\param		red				[in] 16-bits red component
	 *	\param		green			[in] 16-bits green component
	 *	\param		blue			[in] 16-bits blue component
	 *	\param		alpha			[in] 16-bits alpha component
	 *	\return		true if success
	 */
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	bool			FillTexture(BitmapStorage* bitmap_storage, uword red, uword green, uword blue, uword alpha);

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 *	Fills a MAX bitmap array with a given array of colors.
	 *	\param		bitmap_storage	[out] MAX bitmap storage pointer
	 *	\param		pixels			[in] source picture
	 *	\param		alpha			[in] alpha component for all pixels
	 *	\return		true if success
	 */
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	bool			CopyToTexture(BitmapStorage* bitmap_storage, const Point* pixels, uword alpha);

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 *	Copies a MAX native prs to our own prs.
	 *	\param		prs				[out] destination structure
	 *	\param		affine_parts	[in] source MAX structure
	 */
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void			CopyPRS(PRS& prs, const AffineParts& affine_parts);

	void			GetScaling(Point& scaling, INode* node, TimeValue frame, bool from_node=false);

	bool			AreEqual(void* text0, void* text1);

	bool			HasCustomMaterial(INode* node, const char* class_name, int* index=null);

	Modifier*		FindModifier(INode* node, Class_ID class_id);
	bool			DeleteModifier(INode* node, Class_ID class_id);

#endif // FLX_ASK2MAX_H
