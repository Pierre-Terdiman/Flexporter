///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
 *	FLEXPORTER - a flexible exporter
 *	Copyright (C) 2000-2004 Pierre Terdiman
 *	Homepage: http://www.codercorner.com/Flexporter.htm
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	This file contains the main MAX converter.
 *	\file		FLX_MAXConverter.h
 *	\author		Pierre Terdiman
 *	\date		April, 4, 2000
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Include Guard
#ifndef FLX_MAXCONVERTER_H
#define FLX_MAXCONVERTER_H

	#define INIT_PERCENTS	udword OldPercents = INVALID_ID;
	#define UPDATE_PERCENTS(x, max, text)					\
		udword Percents = max ? x*100/max : 0;				\
		if(Percents!=OldPercents)							\
		{													\
			OldPercents = Percents;							\
			SetExtStatus(_F("%s  %d %%", text, Percents));	\
		}

	#define _DUMP_CONTROLLER(text)							\
		/* Perform format-dependent export */				\
		SetExtStatus("calling export plug-in...");			\
		if(mExporter)	mExporter->ExportController(Ctrl);	\
		DumpLogString();									\
		mArrayLog.StoreASCII(_F("(exported controller: %s)\n", text));


	#define	CVT_DEFAULT_SMOOTHING_GROUP	1

	#define	MATID_NO_MATERIAL			-1
	#define	MATID_INVALID				-2

	#define TEXTURE_INVALID				-1
	#define CONTROLLER_CTRL_INVALID		0		// MUST be 0

	class MAXConversionSettings : public ConversionSettings
	{
		public:
						MAXConversionSettings()
						{
							mIp				= null;
							mRootNode		= null;
							mSelectedNodes	= null;
#ifdef SUPPORT_OLD_LIGHTMAPPER
							mLightmapper	= null;
#endif
						}

						Interface*			mIp;			// MAX interface
						INode*				mRootNode;		// MAX root node (can be useful when you don't want to export the whole scene)
						Selection*			mSelectedNodes;	// The possible selection array
#ifdef SUPPORT_OLD_LIGHTMAPPER
						Lightmapper*		mLightmapper;	// Possible lightmapper
#endif
	};

	class ProtectedParameters
	{
		public:
		// Constructor/Destructor
											ProtectedParameters()
											{
												mScaling.x = mScaling.y = mScaling.z = 1.0f;
												ResetXForm();
											}
											~ProtectedParameters()
											{
											}
		//
		inline_			const Point&		GetScaling()					const	{ return mScaling;									}
		inline_			BOOL				HasXForm()						const	{ return mHasXForm;									}
		inline_			const Matrix3x3&	GetXForm()						const	{ return mXForm;									}
		//
		inline_			void				SetScaling(const Point& scale)			{ mScaling = scale;									}
		inline_			void				SetScaling(float x, float y, float z)	{ mScaling.x = x; mScaling.y = y; mScaling.z = z;	}
		inline_			void				SetResetXForm(BOOL flag)				{ mHasXForm = flag;									}
		inline_			void				SetXForm(const Matrix3x3& xform)		{ mXForm = xform;									}
		inline_			void				ResetXForm()							{ mXForm.Identity();	mHasXForm = FALSE;			}

		private:
		// General scaling
						Point				mScaling;
						BOOL				mHasXForm;
						Matrix3x3			mXForm;
	};

	class MAXConverter : public Converter, public ProtectedParameters
	{
		public:
		// Constructor/Destructor
											MAXConverter();
		virtual								~MAXConverter();
		// Exportation dialog control

		// Main conversion call

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	The main conversion entry point.
		 *	\param		params		[in] the conversion settings
		 *	\return		true if success.
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		override(Converter)	bool			Convert(const ConversionSettings* params);

		private:
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	User-callback, called by the parser each time a new line has been found.
		 *	\param		line	[in] the new line
		 *	\param		pb		[in] a parameter-block made from current line
		 *	\return		true to end parsing
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		override(Parsable)	bool			Parameter(const char* line, const ParameterBlock& pb);

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Updates the Status Text of the Export Dialog.
		 *	The status extended text is always cleared when you use this method.
		 *
		 *	\param		text		[in] the string to display
		 *	\return		Self-reference.
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						MAXConverter&		SetStatus(const char* text);
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Updates the Status Extended Text of the Export Dialog.
		 *	\param		text		[in] the string to display
		 *	\return		Self-reference.
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						MAXConverter&		SetExtStatus(const char* text);

		// Log info

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Displays the final log text.
		 *	\return		Self-reference.
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						MAXConverter&		DisplayLogText();

		// Start/End notifications

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	This method is called once before starting the export process.
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		override(Converter)	void			StartExport();
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	This method is called once after the export process.
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		override(Converter)	void			EndExport();

		// Consersion helpers

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Gets the scale factor of a given node.
		 *	This is used to help removing non-uniform scaling in biped objects. After the call mScaling is updated with the new scale.
		 *	Removing non-uniform scaling:
		 *		It seems it should only be done on biped (skeleton) parts, since we're sure the scale won't change from one frame to another.
		 *		For other objects, removing non-uniform scaling seems to be pointless, unless the scale is constant over the active time segment.
		 *
		 *	\param		node		[in] a MAX node
		 *	\param		from_node	[in] true to get scaling from the NodeTM, false to get it from the ObjectTM.
		 *	\return		scaling vector reference
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						const Point&		GetScalingFrom(INode* node, bool from_node=false);
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Exports a header for a given node.
		 *	\param		node		[in] a MAX node
		 *	\param		obj			[out] destination structure
		 *	\return		Self-reference.
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						MAXConverter&		AddHeader(INode* node, ObjectDescriptor* obj);

		// Main conversion loop

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	This is the main recursive conversion method.
		 *	You should call it once for the root node and let it be...
		 *	\param		current_node	[in] a MAX node
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						void				_AddNode(INode* current_node);

		// Add methods

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Converts a geom-object.
		 *	\param		node			[in] the MAX node
		 *	\param		derived_object	[in] a possible collapsed derived object
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						bool				AddGeomObject(INode* node, Object* derived_object=null);
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Converts a so-called "derived object". Includes non-collapsed objects as well as Character Studio's objects.
		 *	We force GeomObjects to collapse and call the right export method, unless the derived object is something we know how to handle.
		 *
		 *	\param		node	[in] a MAX node
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						bool				AddDerivedObject(INode* node);
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Converts a camera.
		 *	\param		node			[in] the MAX node
		 *	\param		derived_object	[in] a possible collapsed derived object
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						bool				AddCamera(INode* node, Object* derived_object=null);
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Converts a light.
		 *	\param		node			[in] the MAX node
		 *	\param		derived_object	[in] a possible collapsed derived object
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						bool				AddLight(INode* node, Object* derived_object=null);
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Converts a shape.
		 *	\param		node			[in] the MAX node
		 *	\param		derived_object	[in] a possible collapsed derived object
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						bool				AddShape(INode* node, Object* derived_object=null);
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Converts a helper.
		 *	\param		node			[in] the MAX node
		 *	\param		derived_object	[in] a possible collapsed derived object
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						bool				AddHelper(INode* node, Object* derived_object=null);
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Converts a space warp object.
		 *	\param		node			[in] the MAX node
		 *	\param		derived_object	[in] a possible collapsed derived object
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						bool				AddSpaceWarp(INode* node, Object* derived_object=null);

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Converts a motion.
		 *	\param		charid		[in] character ID
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						bool				AddMotion(udword charid);
						MAXConverter&		ExportBonePRS(INode* node, CustomArray& array);

		// Material conversion

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Computes a material ID.
		 *	MAX guys must've had a sordid mental hangover the day they dealt with material IDs....
		 *	\param		node		[in] a MAX node
		 *	\param		mesh		[in] a MAX mesh
		 *	\param		i			[in] face number
		 *	\param		relative	[in] true to compute relative index, else absolute index
		 *	\return		valid material ID
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						long				ComputeMaterialID(INode* node, ::Mesh* mesh, long i, bool relative=false);
						udword				RemapMaterialID(udword matid);
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Exports materials from a node.
		 *	Materials from mCurrentNbMtls to mStats.NbMaterials are stored in the global info array.
		 *	\param		node	[in] a MAX node
		 *	\return		true if sucess.
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						bool				AddMetaMaterial(INode* node);
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Exports a material and possible submaterials.
		 *	\param		material	[in] a MAX material
		 *	\return		true if sucess.
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						bool				_AddMaterial(Mtl* material);
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Exports a standard material.
		 *	\param		material	[in] a MAX material
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						void				AddStdMaterial(Mtl* material);
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Exports a default material.
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						void				AddDefaultMaterial();
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	This method is called in the end, to convert all used materials.
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						bool				ConvertMaterials();
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Converts a MAX StdMaterial to correct format.
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						bool				ConvertStdMaterial(udword mtlnb, udword trueid);
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Converts a default StdMaterial to correct format.
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						bool				ConvertDefaultMaterial(udword trueid);

						bool				SameMaterial(Mtl* material0, Mtl* material1);

		// Texture conversion

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Exports texmaps. Only bitmap-texmap are exported.
		 *	\param		tb		[in] texture blend info
		 *	\return		0 if failed, else the texmap's ID
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						long				AddTexture(TextureBlend& tb);
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Computes the size of the destination texture, according to user settings.
		 *	\param		source		[in] the source picture
		 *	\return		the destination texture size (for both width & height)
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						udword				ComputeTextureSize(const Picture& source)	const;
						bool				CheckTextureSize(udword size, const char* name);
				//		bool				ConvertHeightFieldToNormalMap(Picture& srcpic);

		// Consolidation

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Builds a convex hull.
		 *	\param		meshinf		[in] the mesh info structure
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						bool				BuildConvexHull(MeshDescriptor& meshinf);
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Builds a bounding sphere.
		 *	\param		meshinf		[in] the mesh info structure
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						bool				BuildBoundingSphere(MeshDescriptor& meshinf);
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Computes the inertia tensor.
		 *	\param		meshinf		[in] the mesh info structure
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						bool				ComputeInertiaTensor(MeshDescriptor& meshinf);
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Consolidates the mesh.
		 *	\param		meshinf		[in] the mesh info structure
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						bool				ConsolidateMesh(MeshDescriptor& meshinf);
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Builds a MAX native mesh.
		 *	\param		mesh_desc		[in] the mesh info structure
		 *	\param		node_object		[in] the current mesh object
		 *	\param		node			[in] the MAX node
		 *	\return		Self-reference
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						bool				BuildMesh(MeshDescriptor& mesh_desc, Object* node_object, INode* node);
						bool				SetupVertexData(MeshDescriptor& mesh_desc, Object* node_object);
						bool				SetupExtraMap(MeshDescriptor& mesh_desc, const MAXMeshPointer& mesh);
						bool				SetupTopologies(INode* node, MeshDescriptor& mesh_desc, const MAXMeshPointer& mesh);
						bool				BuildSkin(MeshDescriptor& meshinf, Object* node_object, INode* node, IPhyContextExport* pc_export);
						bool				BuildSkin(MeshDescriptor& meshinf, Object* node_object, INode* node, ISkin* skin, ISkinContextData* skin_context);
						bool				BuildSkeleton(MeshDescriptor& mesh_desc);
		// PRS stuff

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Gets a PRS
		 *	\param		node						[in] the MAX node
		 *	\param		time_value					[in] the frame number
		 *	\param		remove_non_uniform_scaling	[in] true to remove non-uniform scaling
		 *	\param		static_prs					[out] the result structure
		 *	\return		Self-Reference
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						MAXConverter&		GetStaticPRS(INode* node, long time_value, bool remove_non_uniform_scaling, AffineParts& static_prs);
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Converts the PRS of a given node, at a given time
		 *	\param		node			[in] the MAX node
		 *	\param		time_value		[in] the frame number
		 *	\param		prs				[out] a PRS structure to fill with converted data
		 *	\return		Self-Reference
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						MAXConverter&		ConvertPRS(INode* node, long time_value, PRS& prs);
						void				ConvertPRS(PRS& prs);

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Converts the pivot.
		 *	\param		node	[in] the MAX node
		 *	\param		pivot	[out] pivot information
		 *	\return		Self-Reference
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						MAXConverter&		GetPivot(INode* node, Pivot& pivot);
		// Controllers

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Creates sampled PRS data.
		 *	\param		node	[in] the MAX node
		 *	\param		ctype	[in] the controller's type (PR or PRS)
		 *	\param		data	[out] an array to store the sampled data
		 *	\return		number of samples
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						udword				CreateSampledPRSData(INode* node, ControllerType ctype, CustomArray& data);
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Creates keyframed PRS data.
		 *	\param		anim		[in] a MAX animatable
		 *	\param		data		[out] an array to store the keyframed data
		 *	\param		ctrltype	[out] controlled type
		 *	\return		number of keyframes
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						udword				CreateKeyframedData(Animatable* anim, CustomArray& data, MAXCtrlType& ctrltype);
						bool				ExportKeyframes(Animatable* anim, const char* name, const char* log_name, ResourceDescriptor* exported_node);

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Creates a PRS controller.
		 *	\param		node			[in] the MAX node
		 *	\param		exported_node	[in] the exported node's info structure
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						bool				AddPRSController(INode* node, ResourceDescriptor* exported_node);
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Creates a visibility controller. (export the visibility track)
		 *	\param		node			[in] the MAX node
		 *	\param		exported_node	[in] the exported node's info structure
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						bool				AddVisibilityController(INode* node, ResourceDescriptor* exported_node);
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Creates a morph controller.
		 *	\param		node			[in] the MAX node
		 *	\param		exported_node	[in] the exported node's info structure
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						bool				AddMorphController(INode* node, ResourceDescriptor* exported_node);
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Creates a FOV controller.
		 *	\param		camera			[in] the MAX camera
		 *	\param		exported_node	[in] the exported node's info structure
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						bool				AddFOVController(GenCamera* camera, ResourceDescriptor* exported_node);
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Creates a float controller.
		 *	\param		anim			[in] a MAX animatable
		 *	\param		exported_node	[in] the exported node's info structure
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						bool				AddFloatController(Animatable* anim, ResourceDescriptor* exported_node, const char* name, SAMPLE_FLOAT_CALLBACK cb, udword user_data);
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Creates a Point controller.
		 *	\param		anim			[in] a MAX animatable
		 *	\param		exported_node	[in] the exported node's info structure
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						bool				AddPointController(Animatable* anim, ResourceDescriptor* exported_node, const char* name, SAMPLE_POINT_CALLBACK cb, udword user_data);
		// Misc
						void				DumpSubAnimsNames(Animatable* node);
#ifndef FLEXPORTER_MAX3
						bool				DumpIKData(IIKControl* ik);
#endif
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Gets IK data from a node.
		 *	\param		node	[in] a MAX node
		 *	\param		obj		[out] filled with IK data
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						void				GetIK(INode* node, ObjectDescriptor& obj);
		private:
		// Exportation dialog
						IceExportDlg*		mDialog;
						long				mCurrentConvertedNode;
		// Exportation settings
						Interface*			mIp;
						INode*				mRootNode;
						Selection*			mSelectedNodes;
#ifdef SUPPORT_OLD_LIGHTMAPPER
						Lightmapper*		mMapper;
#endif
		// User-defined properties
						UserProps			mProps;
		// Active time segment
						MAXTimeInfo			mTimeInfo;
		// Scene composition
						StatsDescriptor		mStats;
						String				mSceneHelpText;		//!< Help text made out of scene info
						String				mSceneInfo;			//!< Remaining scene info (without already used lines)
		// General information
						GlobalInfo			mGlobalInfo;
		// Materials
						long				mNbSubMtls;			// #subMaterials for current material
						long				mCurrentNbMtls;
						udword				mNbUsedMaterials;
						Container			mUsedMaterials;
		// Settings
						bool				mExportUVW;			// For currently exported node
						bool				mExportColors;		// For currently exported node
						bool				mParity;			// For currently exported node
#ifdef SUPPORT_OLD_LIGHTMAPPER
						bool				mLightmapPass;
#endif
						bool				mParseSceneInfos;	//!< Parser is currently parsing scene information
						bool				mHelpText;			//!< Parser is currently building scene's help text
		// Scene parameters
						udword				mTesselation;		//!< Tesselation level (0 = don't tesselate)
						udword				mLightingMode;		//!< Lighting mode
			// Scene physics
						Point				mGravity;
						float				mRestitution;
						float				mStaticFriction;
						float				mFriction;
						bool				mGroundPlane;
						bool				mCollisionDetection;
		// Internal methods
						bool				AddPrimitive(Object* node_object, MeshDescriptor& mesh_desc);
	};

#endif // FLX_MAXCONVERTER_H
