///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
 *	FLEXPORTER - a flexible exporter
 *	Copyright (C) 2000-2004 Pierre Terdiman
 *	Homepage: http://www.codercorner.com/Flexporter.htm
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Precompiled Header
#include "Stdafx.h"

using namespace Flexporter;

udword Flexporter::GetSizeOf(ControllerType type)
{
			if(type==FLX_CTRL_FLOAT)	return sizeof(CtrlFloat);
	else	if(type==FLX_CTRL_VECTOR)	return sizeof(CtrlVector);
	else	if(type==FLX_CTRL_QUAT)		return sizeof(CtrlQuat);
	else	if(type==FLX_CTRL_SCALE)	return sizeof(CtrlScale);
	else	if(type==FLX_CTRL_PR)		return sizeof(CtrlPR);
	else	if(type==FLX_CTRL_PRS)		return sizeof(CtrlPRS);

	return 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Constructor.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ControllerData::ControllerData() : mType(FLX_CTRL_DWORD), mMode(CTRL_FORCE_DWORD), mFlags(0)
{
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Destructor.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ControllerData::~ControllerData()
{
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Constructor.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
SampleData::SampleData() : mNbSamples(0), mSamples(null)
{
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Destructor.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
SampleData::~SampleData()
{
	DELETESINGLE(mSamples);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	A method to initialize the sample container.
 *	\param		create	[in] creation structure
 *	\return		true if success
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool SampleData::Init(ControllerDataCreate* create)
{
	// Checkings
	if(!create)	return false;

	// Cast
	SampleDataCreate* sdc = (SampleDataCreate*)create;

	// Check value
	if(!sdc->NbSamples)	return false;

	// Copy items
	mType			= sdc->Type;
	mMode			= sdc->Mode;
	mNbSamples		= sdc->NbSamples;
	mSamplingRate	= sdc->SamplingRate;

	udword Size = GetSizeOf(mType);
	if(!Size)	return false;

	// Get some bytes
	mSamples = new ubyte[mNbSamples*Size];
	CHECKALLOC(mSamples);

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Constructor.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
KeyframeData::KeyframeData() : mNbKeyframes(0), mScheme(FLX_SCHEME_UNKNOWN), mKeyframes(null)
{
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Destructor.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
KeyframeData::~KeyframeData()
{
	DELETESINGLE(mKeyframes);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	A method to initialize the keyframe container.
 *	\param		create	[in] creation structure
 *	\return		true if success
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool KeyframeData::Init(ControllerDataCreate* create)
{
	// Checkings
	if(!create)	return false;

	// Cast
	KeyframeDataCreate* kdc = (KeyframeDataCreate*)create;

	// Check value
	if(!kdc->NbKeyframes)	return false;

	// Copy items
	mType			= kdc->Type;
	mMode			= kdc->Mode;
	mNbKeyframes	= kdc->NbKeyframes;
	mScheme			= kdc->Scheme;

	udword Size = 0;
	switch(mScheme)
	{
		case FLX_SCHEME_LINEAR:
		{
					if(mType==FLX_CTRL_FLOAT)	Size = sizeof(LinearFloatKey);
			else	if(mType==FLX_CTRL_VECTOR)	Size = sizeof(LinearPointKey);
			else	if(mType==FLX_CTRL_QUAT)	Size = sizeof(LinearRotKey);
			else	if(mType==FLX_CTRL_SCALE)	Size = sizeof(LinearScaleKey);
		}
		break;
		case FLX_SCHEME_TCB:
		{
					if(mType==FLX_CTRL_FLOAT)	Size = sizeof(TCBFloatKey);
			else	if(mType==FLX_CTRL_VECTOR)	Size = sizeof(TCBPointKey);
			else	if(mType==FLX_CTRL_QUAT)	Size = sizeof(TCBRotKey);
			else	if(mType==FLX_CTRL_SCALE)	Size = sizeof(TCBScaleKey);
		}
		break;
		case FLX_SCHEME_BEZIER:
		{
					if(mType==FLX_CTRL_FLOAT)	Size = sizeof(BezierFloatKey);
			else	if(mType==FLX_CTRL_VECTOR)	Size = sizeof(BezierPointKey);
			else	if(mType==FLX_CTRL_QUAT)	Size = sizeof(BezierRotKey);
			else	if(mType==FLX_CTRL_SCALE)	Size = sizeof(BezierScaleKey);
		}
		break;
	}
	if(!Size)	return false;

	// Get some bytes
	mKeyframes = new ubyte[mNbKeyframes*Size];
	CHECKALLOC(mKeyframes);

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Constructor.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MorphData::MorphData() : mNbVertices(0)
{
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Destructor.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MorphData::~MorphData()
{
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	A method to initialize the morphing container.
 *	\param		create	[in] creation structure
 *	\return		true if success
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool MorphData::Init(ControllerDataCreate* create)
{
	// Checkings
	if(!create)	return false;

	// Cast
	MorphDataCreate* mdc = (MorphDataCreate*)create;

	// Check values
	if(!mdc->NbVertices)	return false;
	if(!mdc->NbSamples)		return false;

	// Copy items
	mType			= mdc->Type;
	mMode			= mdc->Mode;
	mNbSamples		= mdc->NbSamples;
	mSamplingRate	= mdc->SamplingRate;
	mNbVertices		= mdc->NbVertices;

	// Check type
	if(mType!=FLX_CTRL_VERTEXCLOUD)	return false;

	// Compute sample size
	udword Size = mNbVertices*sizeof(CtrlVector);

	// Get some bytes
	mSamples = new ubyte[mNbSamples*Size];
	CHECKALLOC(mSamples);

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Constructor.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ControllerDescriptor::ControllerDescriptor() : mObjectID(-1), mOwnerID(-1), mOwnerType(FLX_OBJ_UNDEFINED), mData(null)
{
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Destructor.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ControllerDescriptor::~ControllerDescriptor()
{
	DELETESINGLE(mData);
}
